## 第七章:封装

## 一、回顾

 ```xml
1.类和对象
2.类的概念
	具有一组相同属性和行为的集合;
	类是对象的抽象;修饰类的关键字  class
3.发现类
	a.根据实际事物抽象出类
	b.找出类的特征(属性),值关注自己需要的属性;
	c.找出共同的行为
4.属性
	成员变量,全局变量都表示属性。定义: [修饰符] 数据类型 属性名 = [初始值];

5.方法|行为|函数
	方法可以理解为具有特定功能的一个小代码块。
	
	定义方法的格式:
		[修饰符] 返回值 方法名([形参列表]){//方法体  [return 具体值]}
	
	方法的四要素:
		a.返回值
			i:如果方法没有返回值  使用void修饰
			ii:有返回值返回具体的类型,需要在方法的内部使用 return 关键字
			iii:有返回值的方法，调用的时候 可以使用变量接收。
		b.方法名
			i:符号标识符命名规则。
		c.形参列表
			i:形参列表  可以同时拥有多个参数
			ii:参数的作用域 只在该方法体中有效
		d.方法体
			i:具体的功能
			ii:建议不超过 100行数据
		

6.构造方法|构造器
	


7.对象
	a.万物皆对象
	b.对象是实实在在的事物
	c.对象是类的实例化，也是类的具体体现形式

	创建对象:
	类名 obj = new +类名();

	对象调用属性和方法
	obj.属性   obj.方法



6.类的访问机制
	a.在同一个类中访问
		普通方法之间可以进行相互调用，可以不用使用对象.(内置的this) (同等级别:静态的|普通的)
	b.在不同的类中访问
		先创建对象，通过对象 obj.属性   obj.方法名
 ```

**构造方法|构造器**

``` xml
1.作用
	a.用来初始化(创建)对象	
	b.按照指定的方式来创建
	

2.特点
	a.默认拥有一个无参的构造方法
	b.如果定义了有参构造方法，那么默认的无参构造就会消失。如果需要得自己重新定义
	c.构造方法 没有返回值，也不用使用void修饰。方法名和类名相同
	d.构造方法不能使用 void修饰，如果修饰就会变成普通方法   
	
3.和普通的区别(什么时候使用构造，什么时候使用普通方法)
```



**主要内容:面向对象的特性---封装**



## 二、封装和隐藏

``` xml
1.概述
	a.封装 隐藏内部实现细节，对外提供一个统一访问的接口
	b.隐藏 就是private修饰，除了自己 别人无法访问。
2.作用
	隐藏一个类的实现细节；
	使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；
	便于修改，增强代码的可维护性；
```

### 2.1 访问修饰符

| 访问修饰符 | private | 默认(default) | protected | public |
| ---------- | ------- | ------------- | --------- | ------ |
| 本类       | 可以    | 可以          | 可以      | 可以   |
| 同包       | 不      | 可以          | 可以      | 可以   |
| 子类       | 不      | 不            | 可以      | 可以   |
| 整个项目   | 不      | 不            | 不        | 可以   |



### 2.2 构造方法

``` xml
1.特征
	它具有与类相同的名称；
	它不含返回值；
		注意：在构造方法里不含返回值的概念是不同于“void”的，在定义构造方法时加了“void”，结果这个方法就		 不再被自动调了。
	一个类中可以拥有多个构造方法

2.作用
	当一个类的实例对象刚产生时，这个类的构造方法就会被自动调用，我们可以在这个方法中加入要完成初始化工作	  的代码
	按照指定的规则来创建对象,完成对象的初始化工资;(给所有的属性赋值)

	注意: 构造方法不能使用void修饰，否则就是普通方法。丧失了构造方法的作用
		 构造方法通过new 关键字 调用。不能通过对象调用  : 
			new Person();   //调用Person无参构造
			new User("zhangsan", "深圳华美居", "110")； //调用有参数构造
	
3.构造方法注意
a.Java语言中，每个类都至少有一个构造方法；
b.如果类的定义者没有显式的定义任何构造方法，系统将自动提供一个默认的构造方法：
	默认构造方法没有参数
	默认构造方法没有方法体
	默认的构造方法：Animal(){}
 	所以：不编写构造方法就能用new Xxx()创建类的实例。
c.Java类中，一旦类的定义者显式定义了一个或多个构造方法，系统将不再提供默认的构造方法；
构造器的主要作用：利用构造器参数初始化对象的属性。
```



### 2.3 方法的重载

``` xml
方法的重载:
	在同一个类中同名不同参数的方法，称之为方法的重载;

满足重载的条件
	a.方法的形参列表，必须不同(参数的个数,参数的类型,参数的顺序至少有一个不一样)
	b.多个方法的返回值可以相同，也可以不相同
	c.调用重载方法的时候，具体调用哪一个方法，取决于 传入的实参的数据类型。
```



### 2.4 可变参数

``` xml
1.形参列表是动态可变的。根据实参的个数

```



### 2.5 构造方法重载

``` xml
语法和普通方法一样。在调用的时候 使用 new 构造方法(实参)
```



### 2.6 this

``` xml
1.this 表示当前对象的意思
2.没有被static修饰的方法，都可以直接使用this
3.this可以调用当前类的成员变量，成员方法，构造方法
	a.this调用成员变量  调用属性    this.name
	b.this调用成员方法   this.getAge();
	c.this调用构造方法
		i:构造方法与构造方法之间可以调用
		ii:必须写在构造方法的第一行

```

``` java
public class Person {
	private String name;
	private int age;
	private Date birthDate; // 日期

	public Person(String name, int age, Date d) {
		this.name = name;
		this.age = age;
		this.birthDate = d;
	}

	public Person(String name, int age) {
		this(name, age, new Date()); // this.name=name; this.age=age;
		// this.birthDate=null;
	}

	public Person(String name, Date d) {
		this(name, 30, d); // this.name=name;
		this.age = 30;
		this.birthDate = d;
	}

	public Person(String name) {
		this(name, 30); // this.name=name; this.age=30;
	}

	public void show() {
		System.out.println("name:" + name + " age:" + age + " birthDate:" + birthDate);
	}
}

```



### 2.7 package

``` xml
package com.hzit07;  //
	定义包  如果不写 就是默认包  
	用‘ .’ 来指明包(目录)的层次  com.hzit.xxx
```



### 2.8 import语句 

``` xml
如果是同一个包下，可以不用import。
如果是不同包下，可以使用import引入包
import  包名[.子包名…]. <类名 |*>
import java.util.*; //不推荐
import java.util.Scanner; //

```























